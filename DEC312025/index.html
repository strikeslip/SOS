<!--
[SOS - Sounds Of Seismic]
https://sos.allshookup.org/
Copyright (c) [02025] [SHOOK aka D.V.R.]

SOS is free software: you can redistribute it and/or modify
it under the terms of the MIT License (https://opensource.org/license/mit)
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sounds of Seismic</title>
    
    <link rel="icon" href="favicon.ico" type="image/x-icon"> 
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: #FFFFFF;
            color: #000000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .title {
            font-size: 31px;
            font-weight: 700;
            color: #000000;
            text-align: center;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        .subtitle {
            font-size: 18px;
            font-weight: 700;
            color: #000000;
            text-align: center;
            letter-spacing: 1px;
            margin-bottom: 20px;
        }

        .earthquake-header {
            text-align: center;
            font-size: 12px;
            color: #555;
            margin-bottom: 20px;
            min-height: 20px;
        }

        .earthquake-header.loaded {
            color: #000;
        }

        .earthquake-header strong {
            color: #ed2011;
        }

        .earthquake-header a {
            color: #ed2011;
            text-decoration: none;
            font-weight: bold;
            transition: color 0.3s ease;
        }

        .earthquake-header a:hover {
            color: #cc1a0e;
            text-decoration: underline;
        }

        #canvas-container {
            width: 333px;
            height: 333px;
            cursor: grab;
            margin-bottom: 20px;
            position: relative;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 333px;
            height: 333px;
            background: #FFF;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-content {
            text-align: center;
        }

        .spinner {
            width: 32px;
            height: 32px;
            border: 2px solid #ccc;
            border-top: 2px solid #333;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-content p {
            font-size: 12px;
            color: #666;
        }

        .globe-instruction {
            text-align: center;
            font-size: 12px;
            color: #555;
            margin-bottom: 20px;
            min-height: 20px;
        }

        .links-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px 13px;
            max-width: 600px;
            margin-bottom: 30px;
        }
        
        .line-break {
            flex-basis: 100%;
            height: 0;
        }

        .links-container a {
            color: #000000;
            text-decoration: none;
            font-size: 14px;
            letter-spacing: 1px;
            transition: color 0.3s ease;
        }

        .links-container a:hover {
            color: #ed2011;
        }

        .footer-container {
            text-align: center;
            font-size: 12px;
            color: #555555;
        }

        .footer-container p {
            margin-bottom: 8px;
        }
        
        .footer-container a {
            color: #555555;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        .footer-container a:hover {
            color: #ed2011;
        }

    </style>
</head>
<body>

    <!-- Title -->
    <h1 class="title">Sounds of Seismic</h1>
    
    <!-- Subtitle -->
    <div class="subtitle">Electronica Earthwork</div>
    
    <!-- 3D Canvas Container -->
    <div id="canvas-container">
        <!-- Loading screen -->
        <div id="loading" class="loading-screen">
            <div class="loading-content">
                <div class="spinner"></div>
                <p>Loading Tectonic Data...</p>
            </div>
        </div>
    </div>
    

    <!-- Earthquake Info Header (moved below globe) -->
    <div id="earthquake-header" class="earthquake-header">
        <span id="quake-details-header">Loading latest earthquake data...</span>
    </div>


    <!-- Links Section -->
    <nav class="links-container">
        <a href="https://allshookup.org/seismic-field.html" class="uppercase" target="_blank" rel="noopener noreferrer">SEISMIC FIELD</a>
        <a href="https://sos.allshookup.org/flow.html" class="uppercase" target="_blank" rel="noopener noreferrer">SEISFLOW</a>
        <a href="https://sos.allshookup.org/seis.html" class="uppercase" target="_blank" rel="noopener noreferrer">SEISTRONICA</a>
        <div class="line-break"></div>
        <a href="https://sos.allshookup.org/synths/Kamchatka-8-8-Synth.html" class="uppercase" target="_blank" rel="noopener noreferrer">KAMCHATKA</a>
        <a href="https://sos.allshookup.org/ONE.html" class="uppercase" target="_blank" rel="noopener noreferrer">ONE</a>
        <a href="https://sos.allshookup.org/synths/ANMO-FM-Synth.html" class="uppercase" target="_blank" rel="noopener noreferrer">ANMO SYNTH</a>
        <div class="line-break"></div>
        <a href="https://github.com/strikeslip" class="uppercase" target="_blank" rel="noopener noreferrer">GITHUB</a>
        <a href="https://sos.allshookup.org/ShadowZone.html" class="uppercase" target="_blank" rel="noopener noreferrer">SHADOWZONE</a>
        <a href="https://sos.allshookup.org/readme.html" class="uppercase" target="_blank" rel="noopener noreferrer">README</a>
    </nav>

    <!-- Footer Section -->
    <footer class="footer-container">
        <p>SOS ©© SH00K *02026
    </footer>

    <script>
        // ========================================
        // GLOBAL CONFIGURATION
        // ========================================
        
        const SEISMIC_DATA_DURATION_S = 60;
        const MIN_MAGNITUDE = 6.0;
        const FETCH_TIMESPAN_DAYS = 30;
        const STATION_INFO = { net: "IU", sta: "ANMO", loc: "00", cha: "BHZ" };
        const CHAOS_DURATION_MS = 8000;
        
        // ========================================
        // GLOBAL STATE
        // ========================================
        
        let scene, camera, renderer, globe, tectonicLines;
        let tectonicData = null;
        let isDragging = false;
        let previousMouse = { x: 0, y: 0 };
        let rotation = { x: 0, y: 0 };
        let isChaosMode = false;
        let chaosTimer = null;
        let chaosStartTime = 0;
        let chaosPattern = 0;
        let chaosCounter = 0;
        
        // Audio-specific state
        let audioCtx = null;
        let audioInitialized = false;
        let cachedSeismicData = null;
        let cachedQuakeInfo = null;
        let audioEngine = null;
        let isLoadingSeismic = false;
        
        // ========================================
        // AUDIO ENGINE
        // ========================================
        
        class SeismicAudioEngine {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.reverb = null;
                this.delay = null;
                this.isPlaying = false;
                this.scheduledNodes = [];
                this.seismicBuffer = null;
                this.envelope = null;
                this.grainInterval = null;
                this.currentPattern = 0;
            }
            
            async init(audioContext) {
                this.ctx = audioContext;
                
                // Master gain
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0;
                this.masterGain.connect(this.ctx.destination);
                
                // Create reverb
                await this.createReverb();
                
                // Create delay
                this.createDelay();
                
                return true;
            }
            
            async createReverb() {
                const impulseLength = 2 * this.ctx.sampleRate;
                const impulseBuffer = this.ctx.createBuffer(2, impulseLength, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const data = impulseBuffer.getChannelData(channel);
                    for (let i = 0; i < impulseLength; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / impulseLength, 2.5);
                    }
                }
                
                this.reverb = this.ctx.createConvolver();
                this.reverb.buffer = impulseBuffer;
                const reverbGain = this.ctx.createGain();
                reverbGain.gain.value = 0.3;
                this.reverb.connect(reverbGain).connect(this.masterGain);
            }
            
            createDelay() {
                this.delay = this.ctx.createDelay(2.0);
                this.delay.delayTime.value = 0.25;
                
                const feedback = this.ctx.createGain();
                feedback.gain.value = 0.4;
                
                const wetGain = this.ctx.createGain();
                wetGain.gain.value = 0.25;
                
                this.delay.connect(feedback);
                feedback.connect(this.delay);
                this.delay.connect(wetGain).connect(this.masterGain);
            }
            
            setSeismicData(buffer, envelope) {
                this.seismicBuffer = buffer;
                this.envelope = envelope;
            }
            
            start(patternIndex) {
                if (this.isPlaying) return;
                this.isPlaying = true;
                this.currentPattern = patternIndex;
                
                // Fade in master gain
                this.masterGain.gain.cancelScheduledValues(this.ctx.currentTime);
                this.masterGain.gain.setValueAtTime(0, this.ctx.currentTime);
                this.masterGain.gain.linearRampToValueAtTime(0.7, this.ctx.currentTime + 0.5);
                
                // Start different synthesis based on pattern
                this.startPatternSynthesis(patternIndex);
                
                // Schedule fade out after 7.5 seconds
                this.masterGain.gain.setValueAtTime(0.7, this.ctx.currentTime + 7);
                this.masterGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 8);
            }
            
            startPatternSynthesis(pattern) {
                // Reordered patterns: old pattern 3 is now first, old patterns 1 and 2 moved to end
                const patterns = [
                    () => { this.startBass(); this.startGranular('reverse'); },      // old pattern 3 -> new pattern 1
                    () => { this.startBass(); this.startArpeggio(); },              // old pattern 4 -> new pattern 2
                    () => { this.startArpeggio(); this.startGranular('stutter'); }, // old pattern 5 -> new pattern 3
                    () => { this.startDrone(); this.startBass(); },                 // old pattern 6 -> new pattern 4
                    () => { this.startGranular('chaos'); this.startArpeggio(); },   // old pattern 7 -> new pattern 5
                    () => { this.startDrone(); this.startBass(); this.startArpeggio(); }, // old pattern 8 -> new pattern 6
                    () => { this.startDrone(); this.startGranular('random'); },     // old pattern 1 -> new pattern 7
                    () => { this.startDrone(); this.startGranular('forward'); }     // old pattern 2 -> new pattern 8
                ];
                
                if (patterns[pattern]) {
                    patterns[pattern]();
                }
            }
            
            startDrone() {
                if (!this.seismicBuffer || !this.ctx) return;
                
                const osc = this.ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = 55; // Low A
                
                const modOsc = this.ctx.createOscillator();
                modOsc.type = 'sine';
                modOsc.frequency.value = 3;
                
                const modGain = this.ctx.createGain();
                modGain.gain.value = 20;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                filter.Q.value = 5;
                
                const gain = this.ctx.createGain();
                gain.gain.value = 0.15;
                
                // Use envelope to modulate filter
                if (this.envelope && this.envelope.length > 0) {
                    const envDuration = 8;
                    const envSteps = Math.min(this.envelope.length, 100);
                    const stepDuration = envDuration / envSteps;
                    
                    for (let i = 0; i < envSteps; i++) {
                        const time = this.ctx.currentTime + (i * stepDuration);
                        const envValue = this.envelope[Math.floor(i * this.envelope.length / envSteps)];
                        filter.frequency.setValueAtTime(200 + envValue * 2000, time);
                    }
                }
                
                modOsc.connect(modGain).connect(osc.frequency);
                osc.connect(filter).connect(gain);
                gain.connect(this.masterGain);
                if (this.reverb) gain.connect(this.reverb);
                
                osc.start(this.ctx.currentTime);
                modOsc.start(this.ctx.currentTime);
                osc.stop(this.ctx.currentTime + 8);
                modOsc.stop(this.ctx.currentTime + 8);
                
                this.scheduledNodes.push(osc, modOsc);
            }
            
            startBass() {
                const notes = [36, 38, 41, 43]; // C, D, F, G
                let noteIndex = 0;
                const interval = 0.25; // 16th notes at 120 BPM
                
                const playNote = () => {
                    if (!this.isPlaying) return;
                    
                    const freq = 440 * Math.pow(2, (notes[noteIndex % notes.length] - 69) / 12);
                    
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sawtooth';
                    osc.frequency.value = freq;
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 500;
                    filter.Q.value = 10;
                    
                    const gain = this.ctx.createGain();
                    const now = this.ctx.currentTime;
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.2, now + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    
                    osc.connect(filter).connect(gain);
                    gain.connect(this.masterGain);
                    if (this.delay) gain.connect(this.delay);
                    
                    osc.start(now);
                    osc.stop(now + 0.25);
                    
                    noteIndex++;
                    
                    if (this.isPlaying && this.ctx.currentTime < chaosStartTime / 1000 + 7.5) {
                        setTimeout(playNote, interval * 1000);
                    }
                };
                
                playNote();
            }
            
            startArpeggio() {
                const scale = [0, 3, 5, 7, 10, 12]; // Pentatonic
                let noteIndex = 0;
                const rootNote = 72; // C5
                const interval = 0.15;
                
                const playNote = () => {
                    if (!this.isPlaying) return;
                    
                    const midiNote = rootNote + scale[noteIndex % scale.length];
                    const freq = 440 * Math.pow(2, (midiNote - 69) / 12);
                    
                    const osc = this.ctx.createOscillator();
                    osc.type = 'triangle';
                    osc.frequency.value = freq;
                    
                    const gain = this.ctx.createGain();
                    const now = this.ctx.currentTime;
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.1, now + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                    
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    if (this.reverb) gain.connect(this.reverb);
                    
                    osc.start(now);
                    osc.stop(now + 0.4);
                    
                    noteIndex++;
                    
                    if (this.isPlaying && this.ctx.currentTime < chaosStartTime / 1000 + 7.5) {
                        setTimeout(playNote, interval * 1000);
                    }
                };
                
                playNote();
            }
            
            startGranular(style) {
                if (!this.seismicBuffer) return;
                
                let position = 0;
                const grainDuration = 0.1;
                const grainInterval = 50; // ms
                
                const playGrain = () => {
                    if (!this.isPlaying || !this.seismicBuffer) return;
                    
                    const bufferLength = this.seismicBuffer.length;
                    const actualSampleRate = this.ctx.sampleRate;
                    const bufferDurationSeconds = bufferLength / actualSampleRate;
                    
                    // Calculate grain size in samples based on actual sample rate
                    const grainSizeInSamples = Math.floor(grainDuration * actualSampleRate);
                    
                    // Calculate grain position based on style
                    let startSample = 0;
                    switch(style) {
                        case 'forward':
                            startSample = Math.floor(position * actualSampleRate);
                            position = (position + grainDuration) % bufferDurationSeconds;
                            break;
                        case 'reverse':
                            startSample = Math.floor(position * actualSampleRate);
                            position = Math.max(0, position - grainDuration);
                            if (position === 0) position = bufferDurationSeconds;
                            break;
                        case 'stutter':
                            startSample = Math.floor((position % 0.5) * actualSampleRate);
                            if (Math.random() > 0.7) position += 0.5;
                            break;
                        case 'chaos':
                            // Fixed calculation for chaos style
                            const maxStartPosition = Math.max(0, bufferLength - grainSizeInSamples);
                            if (maxStartPosition > 0) {
                                startSample = Math.floor(Math.random() * maxStartPosition);
                            } else {
                                startSample = 0;
                            }
                            break;
                        default: // random
                            // Fixed calculation for random style
                            const maxStart = Math.max(0, bufferLength - grainSizeInSamples);
                            if (maxStart > 0) {
                                startSample = Math.floor(Math.random() * maxStart);
                            } else {
                                startSample = 0;
                            }
                    }
                    
                    // Ensure startSample is within valid range
                    startSample = Math.max(0, Math.min(startSample, bufferLength - 1));
                    
                    // Calculate actual grain samples to copy
                    const grainSamples = Math.min(grainSizeInSamples, bufferLength - startSample);
                    
                    if (grainSamples <= 0) return;
                    
                    // Create grain buffer
                    const buffer = this.ctx.createBuffer(1, grainSamples, actualSampleRate);
                    const channelData = buffer.getChannelData(0);
                    
                    // Copy and apply envelope
                    for (let i = 0; i < grainSamples; i++) {
                        const envelope = Math.sin((i / grainSamples) * Math.PI);
                        const sampleIndex = startSample + i;
                        if (sampleIndex < bufferLength) {
                            channelData[i] = this.seismicBuffer[sampleIndex] * envelope * 0.3;
                        } else {
                            channelData[i] = 0;
                        }
                    }
                    
                    const source = this.ctx.createBufferSource();
                    source.buffer = buffer;
                    source.playbackRate.value = 0.8 + Math.random() * 0.4;
                    
                    const panner = this.ctx.createStereoPanner();
                    panner.pan.value = Math.random() * 2 - 1;
                    
                    const gain = this.ctx.createGain();
                    gain.gain.value = 0.2;
                    
                    source.connect(panner).connect(gain);
                    gain.connect(this.masterGain);
                    if (this.reverb) gain.connect(this.reverb);
                    
                    source.start(this.ctx.currentTime);
                    
                    if (this.isPlaying && this.ctx.currentTime < chaosStartTime / 1000 + 7.5) {
                        setTimeout(playGrain, grainInterval);
                    }
                };
                
                playGrain();
            }
            
            stop() {
                this.isPlaying = false;
                
                // Clear scheduled nodes
                this.scheduledNodes.forEach(node => {
                    try {
                        if (node.stop) node.stop(this.ctx.currentTime + 0.1);
                    } catch(e) {}
                });
                this.scheduledNodes = [];
                
                // Clear grain interval
                if (this.grainInterval) {
                    clearInterval(this.grainInterval);
                    this.grainInterval = null;
                }
                
                // Fade out
                this.masterGain.gain.cancelScheduledValues(this.ctx.currentTime);
                this.masterGain.gain.setValueAtTime(this.masterGain.gain.value, this.ctx.currentTime);
                this.masterGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
            }
        }
        
        // ========================================
        // SEISMIC DATA HANDLING
        // ========================================
        
        async function fetchLatestEarthquake() {
            const end = new Date().toISOString();
            const start = new Date(Date.now() - FETCH_TIMESPAN_DAYS * 24 * 60 * 60 * 1000).toISOString();
            const url = `https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime=${start}&endtime=${end}&minmagnitude=${MIN_MAGNITUDE}&orderby=time`;
            
            try {
                const res = await fetch(url);
                if (!res.ok) throw new Error(`USGS fetch failed: ${res.status}`);
                const data = await res.json();
                
                if (!data.features || data.features.length === 0) {
                    throw new Error(`No earthquakes M>=${MIN_MAGNITUDE} found`);
                }
                
                const event = data.features[0];
                return {
                    place: event.properties.place || "Unknown",
                    mag: event.properties.mag || 0,
                    depth: event.geometry.coordinates[2] || 0,
                    time: new Date(event.properties.time).toISOString(),
                    id: event.id || null,
                    url: event.properties.url || null
                };
            } catch (error) {
                console.error("Error fetching earthquake:", error);
                return null;
            }
        }
        
        async function fetchSeismicWaveform(eventTime) {
            const startTimeISO = eventTime;
            const startTimeMs = new Date(startTimeISO).getTime();
            const endTimeMs = startTimeMs + SEISMIC_DATA_DURATION_S * 1000;
            const endTimeISO = new Date(endTimeMs).toISOString();
            
            const { net, sta, loc, cha } = STATION_INFO;
            const url = `https://service.iris.edu/fdsnws/dataselect/1/query?net=${net}&sta=${sta}&loc=${loc}&cha=${cha}&starttime=${startTimeISO}&endtime=${endTimeISO}&format=miniseed`;
            
            try {
                const res = await fetch(url);
                if (!res.ok) throw new Error(`IRIS fetch failed: ${res.status}`);
                const arrayBuffer = await res.arrayBuffer();
                return parseMiniSEED(arrayBuffer);
            } catch (error) {
                console.error("Error fetching waveform:", error);
                return generateFallbackData();
            }
        }
        
        function parseMiniSEED(buffer) {
            try {
                const view = new DataView(buffer);
                if (buffer.byteLength < 64) throw new Error("Buffer too small");
                
                const numSamples = view.getInt16(46, false);
                const dataOffset = 64;
                
                if (numSamples <= 0 || buffer.byteLength < dataOffset + numSamples * 4) {
                    throw new Error("Invalid sample count");
                }
                
                const rawData = new Int32Array(buffer.slice(dataOffset, dataOffset + numSamples * 4));
                return normalizeData(rawData);
            } catch (error) {
                console.error("MiniSEED parse error:", error);
                return generateFallbackData();
            }
        }
        
        function normalizeData(data) {
            const maxVal = data.reduce((max, val) => Math.max(max, Math.abs(val)), 0);
            if (maxVal === 0) return new Float32Array(data.length);
            
            const normalized = new Float32Array(data.length);
            const factor = 1.0 / maxVal;
            
            for (let i = 0; i < data.length; i++) {
                normalized[i] = data[i] * factor;
            }
            
            return normalized;
        }
        
        function generateFallbackData() {
            const samples = 8192;
            const data = new Float32Array(samples);
            
            for (let i = 0; i < samples; i++) {
                const t = i / samples;
                data[i] = Math.sin(t * Math.PI * 10) * Math.exp(-t * 2) +
                         Math.sin(t * Math.PI * 30) * 0.3 * Math.exp(-t * 4) +
                         (Math.random() - 0.5) * 0.1;
            }
            
            return data;
        }
        
        function extractEnvelope(buffer, windowSize = 512) {
            if (!buffer || buffer.length === 0) return new Float32Array(0);
            
            const numWindows = Math.ceil(buffer.length / windowSize);
            const envelope = new Float32Array(numWindows);
            
            for (let i = 0; i < numWindows; i++) {
                let sum = 0;
                const start = i * windowSize;
                const end = Math.min(start + windowSize, buffer.length);
                
                for (let j = start; j < end; j++) {
                    sum += Math.abs(buffer[j]);
                }
                
                envelope[i] = sum / (end - start);
            }
            
            const maxEnv = Math.max(...envelope);
            if (maxEnv > 0) {
                for (let i = 0; i < envelope.length; i++) {
                    envelope[i] /= maxEnv;
                }
            }
            
            return envelope;
        }
        
        async function preloadSeismicData() {
            if (isLoadingSeismic) return;
            isLoadingSeismic = true;
            
            console.log('Pre-fetching seismic data...');
            
            try {
                const quakeInfo = await fetchLatestEarthquake();
                
                if (quakeInfo) {
                    cachedQuakeInfo = quakeInfo;
                    
                    // Update UI with earthquake info and USGS link
                    const infoEl = document.getElementById('quake-details-header');
                    const magLink = quakeInfo.url ? 
                        `<a href="${quakeInfo.url}" target="_blank" rel="noopener noreferrer">M${quakeInfo.mag.toFixed(1)}</a>` :
                        `<strong>M${quakeInfo.mag.toFixed(1)}</strong>`;
                    
                    infoEl.innerHTML = `Recent: ${magLink} ${quakeInfo.place}`;
                    document.getElementById('earthquake-header').classList.add('loaded');
                    
                    // Fetch waveform data
                    const waveform = await fetchSeismicWaveform(quakeInfo.time);
                    cachedSeismicData = waveform;
                    
                    console.log('Seismic data cached and ready');
                }
            } catch (error) {
                console.error('Error preloading seismic data:', error);
            } finally {
                isLoadingSeismic = false;
            }
        }
        
        // ========================================
        // THREE.JS SCENE
        // ========================================
        
        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xFFFFFF);

            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.z = 4.0; // Moved camera closer for larger globe in 333px canvas

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(333, 333);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createGlobe();
            setupLighting();
        }

        function createGlobe() {
            const globeGeometry = new THREE.SphereGeometry(2, 64, 64);
            const globeMaterial = new THREE.MeshPhongMaterial({
                color: 0x004400,
                wireframe: true,
                wireframeLinewidth: 1,
                transparent: true,
                opacity: 0.6,
                shininess: 30
            });
            globe = new THREE.Mesh(globeGeometry, globeMaterial);
            scene.add(globe);

            const innerGeometry = new THREE.SphereGeometry(1.99, 64, 64);
            const innerMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const innerSphere = new THREE.Mesh(innerGeometry, innerMaterial);
            globe.add(innerSphere);
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            const secondaryLight = new THREE.DirectionalLight(0x404040, 0.3);
            secondaryLight.position.set(-5, -5, -5);
            scene.add(secondaryLight);
        }

        async function loadTectonicData() {
            try {
                console.log('Fetching tectonic plate data...');
                const response = await fetch('https://raw.githubusercontent.com/fraxen/tectonicplates/master/GeoJSON/PB2002_boundaries.json');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                tectonicData = await response.json();
                console.log(`Loaded ${tectonicData.features.length} tectonic boundaries`);
                
                createTectonicLines();
            } catch (error) {
                console.error('Error loading tectonic data:', error);
            }
        }

        function createTectonicLines() {
            if (!tectonicData) return;

            if (tectonicLines) {
                scene.remove(tectonicLines);
            }

            const tectonicGroup = new THREE.Group();
            const colors = [
                0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 
                0xff00ff, 0x00ffff, 0xff8800, 0x8800ff
            ];

            tectonicData.features.forEach((feature, index) => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    const coordinates = feature.geometry.coordinates;
                    const points = [];

                    coordinates.forEach(coord => {
                        const [lon, lat] = coord;
                        const point = latLonToVector3(lat, lon, 2.05);
                        points.push(point);
                    });

                    if (points.length > 1) {
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const material = new THREE.LineBasicMaterial({
                            color: colors[index % colors.length],
                            linewidth: 3,
                        });
                        const line = new THREE.Line(geometry, material);
                        tectonicGroup.add(line);
                    }
                }
            });

            scene.add(tectonicGroup);
            tectonicLines = tectonicGroup;
        }

        function latLonToVector3(lat, lon, radius = 2) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            
            return new THREE.Vector3(
                -radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );
        }

        // ========================================
        // CHAOS MODE WITH AUDIO
        // ========================================
        
        // Reordered chaos patterns: old pattern 3 is now first, old patterns 1 and 2 moved to end
        const chaosPatterns = [
            function(t) { const spiral = t * 2; return { x: Math.sin(spiral) * Math.cos(t * 3) * 0.4, y: Math.cos(spiral) * Math.sin(t * 3) * 0.4, z: Math.sin(t * 7) * 0.3 }; }, // old pattern 3 -> new pattern 1
            function(t) { return { x: Math.sign(Math.sin(t * 15)) * Math.random() * 0.6, y: Math.sign(Math.cos(t * 12)) * Math.random() * 0.5, z: Math.sign(Math.sin(t * 9)) * Math.random() * 0.4 }; }, // old pattern 4 -> new pattern 2
            function(t) { return { x: Math.sin(t * 10) * Math.sin(t * 3) * 0.5, y: Math.cos(t * 8) * Math.cos(t * 5) * 0.4, z: Math.sin(t * 6) * Math.cos(t * 2) * 0.3 }; }, // old pattern 5 -> new pattern 3
            function(t) { return { x: Math.abs(Math.sin(t * 12)) * Math.sign(Math.cos(t * 7)) * 0.6, y: Math.abs(Math.cos(t * 9)) * Math.sign(Math.sin(t * 5)) * 0.5, z: Math.abs(Math.sin(t * 6)) * Math.sign(Math.cos(t * 3)) * 0.4 }; }, // old pattern 6 -> new pattern 4
            function(t) { return { x: Math.sin(t * 4) * Math.cos(t * 8) * 0.5, y: Math.sin(t * 8) * 0.4, z: Math.cos(t * 4) * Math.sin(t * 6) * 0.3 }; }, // old pattern 7 -> new pattern 5
            function(t) { const pulse = Math.abs(Math.sin(t * 6)); return { x: Math.sin(t * 15) * pulse * 0.6, y: Math.cos(t * 18) * pulse * 0.5, z: Math.sin(t * 12) * pulse * 0.4 }; }, // old pattern 8 -> new pattern 6
            function(t) { return { x: Math.sin(t * 13) * 0.3 + Math.cos(t * 17) * 0.2, y: Math.sin(t * 19) * 0.4 + Math.cos(t * 11) * 0.3, z: Math.sin(t * 23) * 0.2 }; }, // old pattern 1 -> new pattern 7
            function(t) { return { x: Math.sin(t * 8) * 0.5, y: Math.cos(t * 6) * 0.4, z: Math.sin(t * 4) * 0.3 }; } // old pattern 2 -> new pattern 8
        ];

        async function startChaosMode() {
            if (isChaosMode) return;
            
            isChaosMode = true;
            chaosStartTime = Date.now();
            chaosPattern = chaosCounter % chaosPatterns.length;
            chaosCounter++;
            
            console.log(`Chaos Mode ${chaosPattern + 1} activated!`);
            
            if (!audioInitialized) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                audioEngine = new SeismicAudioEngine();
                await audioEngine.init(audioCtx);
                audioInitialized = true;
            }
            
            if (cachedSeismicData && audioEngine) {
                const envelope = extractEnvelope(cachedSeismicData);
                audioEngine.setSeismicData(cachedSeismicData, envelope);
                audioEngine.start(chaosPattern);
            }
            
            if (chaosTimer) clearTimeout(chaosTimer);
            
            chaosTimer = setTimeout(() => {
                isChaosMode = false;
                rotation.x = 0;
                rotation.y = 0;
                
                if (audioEngine) {
                    audioEngine.stop();
                }
                
                console.log('Chaos mode ended');
            }, CHAOS_DURATION_MS);
        }

        function setupEventListeners() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('click', (e) => { 
                if (!isDragging) startChaosMode(); 
            });
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMouse = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging || isChaosMode) return;
                const deltaMove = { x: e.clientX - previousMouse.x, y: e.clientY - previousMouse.y };
                rotation.x += deltaMove.y * 0.01;
                rotation.y += deltaMove.x * 0.01;
                previousMouse = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mouseup', () => { 
                isDragging = false; 
                canvas.style.cursor = 'grab'; 
            });
            
            canvas.addEventListener('mouseleave', () => { 
                isDragging = false; 
                canvas.style.cursor = 'grab'; 
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            if (globe) {
                if (isChaosMode) {
                    const elapsed = (Date.now() - chaosStartTime) / 1000;
                    const chaos = chaosPatterns[chaosPattern](elapsed);
                    globe.rotation.x += chaos.x;
                    globe.rotation.y += chaos.y;
                    globe.rotation.z += chaos.z;
                    
                    if (audioEngine && audioEngine.envelope) {
                        const envIndex = Math.floor((elapsed / 8) * audioEngine.envelope.length);
                        if (envIndex < audioEngine.envelope.length) {
                            const intensity = audioEngine.envelope[envIndex];
                            globe.material.opacity = 0.6 + intensity * 0.3;
                            
                            if (tectonicLines) {
                                tectonicLines.children.forEach(line => {
                                    if (line.material) {
                                        line.material.opacity = 0.8 + intensity * 0.2;
                                    }
                                });
                            }
                        }
                    }
                } else {
                    globe.rotation.y += 0.002;
                    globe.rotation.x = rotation.x;
                    globe.rotation.y += rotation.y;
                    
                    if (globe.material.opacity !== 0.6) {
                        globe.material.opacity = 0.6;
                    }
                }

                if (tectonicLines) {
                    tectonicLines.rotation.copy(globe.rotation);
                }
            }
            
            renderer.render(scene, camera);
        }

        // ========================================
        // INITIALIZATION
        // ========================================
        
        async function init() {
            console.log('Initializing Seismic AudioVisual Experience...');
            
            setupScene();
            await loadTectonicData();
            preloadSeismicData();
            setupEventListeners();
            animate();
            
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                console.log('Ready! Click globe to activate seismic sonification');
            }, 1000);
            
            setInterval(preloadSeismicData, 5 * 60 * 1000);
        }

        init();
    </script>
</body>
</html>